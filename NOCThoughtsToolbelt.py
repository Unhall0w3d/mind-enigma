#!/usr/var/python
# -*- code:UTF-8 -*-

#####################################
# Script created by Ken Perry, 2020 #
#       NOC THOUGHTS BLOG           #
# https://nocthoughts.wordpress.com #
#####################################

# Modules Imported for Script Functionality
import subprocess
import time
import xml.etree.ElementTree as ET
from io import BytesIO
import os

import pycurl
import requests
import urllib3
import xml.dom.minidom
from getpass import getpass

# Define Variables
timestr = time.strftime("%Y%m%d-%H%M%S")

# Define disablement of HTTPS Insecure Request error message.
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Define Base URL
axlurl = 'https://'

# Define tmp directory
dirname = 'tmp'

# Define current working directory
dir_path = os.getcwd()

# Define complete path
completepath = os.path.join(dir_path,dirname)


# Define Main Menu
def menu():
    print()
    choice = input("""
                      1: Cisco Phone Requests
                      2: Cisco UCM Requests
                      3: Unimplemented
                      Q: Quit

                      Selection: """)

    if choice == "1":
        phonemenuchoice = input("""
                                1: Pull Cisco Phone Info
                                2: Pull Cisco Phone Logs
                                3: Pull Cisco Device Registration by Device Pool
                                4: Pull Cisco Device Registration by File
                                5: Pull Cisco Device Registration for All
                                Q: Quit

                                Selection: """)
        if phonemenuchoice == "1":
            serialnumpull()
            exit()
        elif phonemenuchoice == "2":
            ips = phonecollection()
            [logcollect(ip_addr) for ip_addr in ips]
            print('############# Files have been stored in ~/ in an IP specific folder #############')
            exit()
        elif phonemenuchoice == "3":
            # User input collection provided by infocollect function
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            # Collect device pool
            cucmdevicepool = collectdevicepool(cucmipaddr, cucmusername, cucmpassword, cucmversion)
            # Call DB Dip Function to execute sql query and prettyprint xml response to file, contains devices to parse
            ucmdbdip_dp(cucmipaddr, cucmversion, cucmpassword, cucmusername, cucmdevicepool)
            # Inform the user what device pool this report is for.
            print()
            print('Registration Report Below For Device Pool: ' + cucmdevicepool + '.')
            print()
            # Pull in device names to check for AST
            for devname in get_devicenames():
                # Hit AST interface to check reg status using csv string generated by createdevstring function
                checkregstate(cucmipaddr, cucmpassword, cucmusername, devname)
            print('Report for Unregistered Devices can be found in UnregisteredDevicesReport' + timestr + '.txt')
            print('Report for Registered Devices can be found in RegisteredDevicesReport' + timestr + '.txt')
            # Perform cleanup of files generated.
            os.remove("regcheckdevicelist.xml")
            os.remove("devicepoollist.xml")
            exit()
        elif phonemenuchoice == "4":
            try:
                # Devname is equal to the returned value from inputfetch(), which is a Comma Separated String drawn from
                # file.
                devname = inputfetch()
                # User input collection provided by infocollect function
                cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
                # Inform the user what device pool this report is for.
                print()
                print('Registration Report Below For Custom List.')
                print()
                checkregstate(cucmipaddr, cucmpassword, cucmusername, devname)
                print('Report for Unregistered Devices can be found in UnregisteredDevicesReport' + timestr + '.txt')
                print('Report for Registered Devies can be found in RegisteredDevicesReport' + timestr + '.txt')
            except FileNotFoundError as x:
                print(x)
            exit()
        elif phonemenuchoice == "5":
            # User input collection provided by infocollect function
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            # Call DB Dip Function to execute sql query and prettyprint xml response to file, contains devices to parse
            ucmdbdip_all(cucmipaddr, cucmversion, cucmpassword, cucmusername)
            # Inform the user what device pool this report is for.
            print()
            print('Registration Report Below For All Devices.')
            print()
            # Pull in device names to check for AST
            for devname in get_devicenames():
                # Hit AST interface to check reg status using csv string generated by createdevstring function
                checkregstate(cucmipaddr, cucmpassword, cucmusername, devname)
            print('Report for Unregistered Devices can be found in UnregisteredDevicesReport' + timestr + '.txt')
            print('Report for Registered Devices can be found in RegisteredDevicesReport' + timestr + '.txt')
            # Perform cleanup of files generated.
            os.remove("regcheckdevicelist.xml")
            exit()
    elif choice == "2":
        ucmmenuchoice = input("""
                                  1: Pull UCM Device Defaults
                                  2: Pull UCM Phones Configured
                                  3: Pull Jabber Last Login Time
                                  4: Pull Devices w/ Static Firmware Assignment
                                  Q: Quit

                                  Selection: """)
        if ucmmenuchoice == "1":
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            devicedefaultsfetch(cucmipaddr, cucmversion, cucmpassword, cucmusername)
            exit()
        elif ucmmenuchoice == "2":
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            ccmphonereport(cucmipaddr, cucmversion, cucmpassword, cucmusername)
            exit()
        elif ucmmenuchoice == "3":
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            jabberlastloginreport(cucmipaddr, cucmversion, cucmpassword, cucmusername)
            exit()
        elif ucmmenuchoice == "4":
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            devicestaticfirmwareassignment(cucmipaddr, cucmversion, cucmpassword, cucmusername)
            exit()
        elif ucmmenuchoice == "5":
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            homeclustercheck(cucmipaddr, cucmversion, cucmusername, cucmpassword)
            exit()
        elif ucmmenuchoice == "q" or "Q":
            exit()
    elif choice == "3":
        print("Not Implemented")
        exit()
    elif choice == "q" or choice == "Q":
        exit()
    else:
        print("You must select an option on the menu.")
        print("Please try again.")
        menu()


# Menu Opt 1 > 1
# Function to perform request to Cisco Phone and store response in buffer.
def getxmldata(ip_addr, uri):
    buffer = BytesIO()
    curl = pycurl.Curl()
    _url = f'http://{ip_addr}{uri}'
    curl.setopt(pycurl.CONNECTTIMEOUT, 5)
    curl.setopt(curl.URL, _url)
    curl.setopt(curl.WRITEDATA, buffer)
    try:
        curl.perform()
        curl.close()
        return ET.fromstring((buffer.getvalue()))
    except pycurl.error:
        print()
        print('Connection Timed Out. No response after 5 seconds for ' + ip_addr + '.')


# Menu Opt 1 > 1
# Function to perform data pull for returned xml code based on tags.
def serialnumpull():
    xmluris = ['/NetworkConfigurationX', '/DeviceInformationX']
    inputfile = input('What is the name of the input text file? (e.g. iplist.txt): ')
    with open(inputfile) as txtfile:
        lines = [line.rstrip() for line in txtfile]
        for line in txtfile:
            lines.append(line)
    for ipaddy in lines:
        try:
            for uri in xmluris:
                root = getxmldata(ipaddy, uri)
                if root == -1:
                    break
                if root is None:
                    continue
                _root = uri.strip('/X')
                for xmltag in root.iter(_root):
                    if xmltag.find('HostName') is not None:
                        macaddr = xmltag.find('HostName').text
                    if xmltag.find('modelNumber') is not None:
                        modelnum = xmltag.find('modelNumber').text
                    if xmltag.find('serialNumber') is not None:
                        serialnum = xmltag.find('serialNumber').text
                    else:
                        serialnum = "n/a"
                    for i in range(2):
                        if xmltag.find('CallManager%s' % (i + 1)) is not None:
                            if xmltag.find('CallManager%s' % (i + 1)).text.find('Active') != -1:
                                cucmreg = xmltag.find('CallManager%s' % (i + 1)).text
            if root == -1:
                continue
            print()
            print("IP:", ipaddy, "DeviceName:", macaddr, "Model:",
                  modelnum, "Serial Number:", serialnum, "Reg State:", cucmreg)
        except Exception as m:
            print(m)
            exit(2)
    return


# Menu Opt 1 > 2
# Function that requests how many phones and their IPs for log collection
def phonecollection():
    num_phones = int(input('How many phones?: '))
    if type(num_phones) != int:
        print('Error: Expected Integer.')
        exit(1)
    ips = []
    for phonecount in range(num_phones):
        ips.append(input('What is the phone IP address?: '))
    return ips


# Menu Opt 1 > 2
# Log collection function that runs wget against consolelog url to pull recursively.
def logcollect(ip_addr):
    destfolder = str('~/')
    uris = list({
        '/CGI/Java/Serviceability?adapter=device.statistics.consolelog',
        '/localmenus.cgi?func=603',
        '/ConsoleLogs',
        '/Console_Logs.htm',
        '/Console_Logs.html',
        '/?adapter=device.statistics.consolelog',
    })
    for uri in uris:
        try:
            response = requests.get(f'http://{ip_addr}{uri}', timeout=6)
            if response.status_code == 200:
                subprocess.call(
                    'wget -T 5 --tries=2 -r --accept "*.log, messages*, *.tar.gz" http://' + ip_addr + uri + ' -P '
                    + destfolder,
                    shell=True)
        except requests.exceptions.ConnectionError:
            print('Far end ' + ip_addr + 'has closed the connection.')
        except requests.exceptions.Timeout:
            print('Connection to ' + ip_addr + ' timed out. Trying next.')
        except Exception as e:
            print('The script failed. Contact script dev with details from your attempt and failure.')
            print(e)


# Info Collect for ip, username, pw, version and initial status code check for all ucm based functions
# Function that gathers input from user for required parameters.
def infocollect():
    # Define user input required for script; pub ip, username, pw.
    ccmip = str(input('What is the target UC Server Pub IP?: '))
    print('Supported SQL DB Versions: 12.5 | 12.0 | 11.5 | 11.0 | 10.5 | 10.0 | 9.1 | 9.0')
    version = str(input('What version is the UC Server?: '))
    myusername = str(input('What is the GUI Username?: '))
    mypassword = getpass('What is the GUI Password?: ')
    try:
        r = requests.get(axlurl + ccmip + '/axl', auth=(myusername, mypassword), verify=False)
        if r.status_code != 200:
            print('AXL Interface is unreachable. Please check connectivity at https://<ucm-ip>/axl.')
            print('Ensure the credentials and version info is correct.')
            print('Script Exiting.')
            exit()
        elif r.status_code == 200:
            return ccmip, version, mypassword, myusername
    except Exception as e:
        print(e)


# Menu Opt 2 > 1
# Function to perform a request against UCM for Device Defaults data and stores response in xml file.
def devicedefaultsfetch(cucmipaddr, cucmversion, cucmpassword, cucmusername):
    # URL to hit for request against axl
    url = (axlurl + cucmipaddr + '/axl/')

    # Payload to send; soap envelope
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/" + cucmversion + "\">\n<!--" \
                                                                     "Like https://[CCM-IP-ADDRESS]/ccmadmin " \
                                                                     "> Device > " \
              "Device Settings > Device Defaults -->\n   <soapenv:Header/>\n   <soapenv:Body>\n     " \
                                                                     " <ns:executeSQLQuery " \
              "sequence=\"\">\n         <sql>\n        SELECT count(dev.tkmodel), tp.name, defaults.tkdeviceprotocol, " \
              "defaults.loadinformation, dev.tkmodel AS tkmodel \n        FROM device AS dev \n        INNER JOIN " \
              "TypeProduct AS tp ON dev.tkmodel=tp.tkmodel \n        INNER JOIN defaults as defaults ON " \
              "tp.tkmodel=defaults.tkmodel \n        WHERE (dev.name like 'SEP%' or dev.name like 'ATA%') \n    " \
                                                                     "    GROUP " \
              "BY dev.tkmodel, tp.name, defaults.loadinformation, defaults.tkdeviceprotocol\n         </sql>\n      " \
              "</ns:executeSQLQuery>\n   </soapenv:Body>\n</soapenv:Envelope> "

    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print()
    print('Collecting Data...')
    print()
    # Here's where we send a POST message out to CUCM, we don't verify certificates.
    response = requests.request("POST", url, headers=headers, data=payload, auth=(cucmusername, cucmpassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    print('Data Collected. Please see file DeviceDefaults' + timestr + cucmipaddr + '.xml.')
    with open(os.path.join(completepath, 'DeviceDefaults_' + timestr + '_' + cucmipaddr + '.xml'), 'w+') as file:
        file.write(xml_pretty_str)


# Menu Opt 2 > 2
# Function to perform a request against UCM for basic phone name, dn, descrip and partition data and stores response
# in xml file.
def ccmphonereport(cucmipaddr, cucmversion, cucmpassword, cucmusername):
    # URL to hit for request against axl
    url = (axlurl + cucmipaddr + '/axl/')
    # Payload to send; soap envelope
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/" + cucmversion + "\">\n<!-- SQL Data Pull for Device Name, Description, " \
              "DN and Partition the DN Sits in for Basic Reporting -->\n   <soapenv:Header/>\n   <soapenv:Body>\n     " \
              " <ns:executeSQLQuery sequence=\"\">\n         <sql>\n\t\t\tSELECT d.name,d.description,n.dnorpattern " \
              "as DN,rp.name as partition\n\t\t\tFROM device as d\n\t\t\tINNER join devicenumplanmap as dmap on " \
              "dmap.fkdevice=d.pkid\n\t\t\tINNER join numplan as n on dmap.fknumplan=n.pkid\n\t\t\tINNER join " \
              "routepartition as rp on n.fkroutepartition=rp.pkid\n\t\t\tWHERE d.tkclass=1\n\t\t\tORDER by d.name\n   " \
              "      </sql>\n      </ns:executeSQLQuery>\n   </soapenv:Body>\n</soapenv:Envelope> "

    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print()
    print('Collecting Data...')
    print()
    # Here's where we send a POST message out to CUCM, we don't verify certificates.
    response = requests.request("POST", url, headers=headers, data=payload, auth=(cucmusername, cucmpassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    print('Data Collected. Please see file PhoneReport' + timestr + cucmipaddr + '.xml.')
    with open(os.path.join(completepath, 'PhoneReport_' + timestr + '_' + cucmipaddr + '.xml'), 'w+') as file:
        file.write(xml_pretty_str)


# Menu Opt 2 > 3
# Function to perform a request against Cisco IM&P Server for information relating to last login time for user
# account and stores response in xml file.
def jabberlastloginreport(cucmipaddr, cucmversion, cucmpassword, cucmusername):
    # URL to hit for request against axl
    url = (axlurl + cucmipaddr + '/axl/')
    # Payload to send; soap envelope
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/" + cucmversion + "\">\n<!--Verifies the last time a Jabber user logged in, " \
              "or the last time their profile was accessed-->\n   <soapenv:Header/>\n   <soapenv:Body>\n      " \
              "<ns:executeSQLQuery sequence=\"\">\n         <sql>\n            SELECT e.userid, cd.timelastaccessed\n " \
              "           FROM enduser as e, credentialdynamic as cd, credential as cr\n            WHERE " \
              "e.pkid=cr.fkenduser and e.tkuserprofile=1 and e.primarynodeid is not null and cr.tkcredential=3 and " \
              "cr.pkid=cd.fkcredential\n            ORDER by cd.timelastaccessed\n         </sql>\n      " \
              "</ns:executeSQLQuery>\n   </soapenv:Body>\n</soapenv:Envelope> "
    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print()
    print('Collecting Data...')
    print()
    # Here's where we send a POST message out to CUCM, we don't verify certificates.
    response = requests.request("POST", url, headers=headers, data=payload, auth=(cucmusername, cucmpassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    print('Data Collected. Please see file JabberLastLogin' + timestr + cucmipaddr + '.xml.')
    with open(os.path.join(completepath, 'JabberLastLogin_' + timestr + '_' + cucmipaddr + '.xml'), 'w+') as file:
        file.write(xml_pretty_str)


# Menu Opt 2 > 4
# Function to perform a request against UCM for Devices with Static Firmware Assignments and stores response in xml
# file.
def devicestaticfirmwareassignment(cucmipaddr, cucmversion, cucmpassword, cucmusername):
    # URL to hit for request against axl
    url = (axlurl + cucmipaddr + '/axl/')
    # Payload to send; soap envelope
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/" + cucmversion + "\">\n<!-- Like https://[CCM-IP-ADDRESS]/ccmadmin > Device " \
              "> Device Settings > Device Firmware Load Information -->\n   <soapenv:Header/>\n   <soapenv:Body>\n    " \
              "  <ns:executeSQLQuery sequence=\"\">\n         <sql>\n            SELECT d.name, " \
              "d.specialloadinformation, d.description, tp.name AS model\n            FROM device AS d\n            " \
              "INNER JOIN TypeProduct AS tp ON d.tkmodel=tp.tkmodel\n            WHERE d.name like 'SEP%' AND " \
              "d.specialloadinformation != ''\n         </sql>\n      </ns:executeSQLQuery>\n   " \
              "</soapenv:Body>\n</soapenv:Envelope>\n "

    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print()
    print('Collecting Data...')
    print()
    # Here's where we send a POST message out to CUCM, we don't verify certificates.
    response = requests.request("POST", url, headers=headers, data=payload, auth=(cucmusername, cucmpassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    print('Data Collected. Please see file DevicesStaticFirmwareAssignment' + timestr + cucmipaddr + '.xml.')
    with open(os.path.join(completepath, 'DevicesStaticFirmwareAssignment_' + timestr + '_' + cucmipaddr + '.xml'), 'w+')\
            as file:
        file.write(xml_pretty_str)


# Menu Opt 2 > 5
# Function to perform a request against UCM for Device Defaults data and stores response in xml file.
def homeclustercheck(cucmipaddr, cucmversion, cucmpassword, cucmusername):
    # URL to hit for request against axl
    url = (axlurl + cucmipaddr + '/axl/')
    # Payload to send; soap envelope
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/" + cucmversion + "\">\n   <soapenv:Header/>\n   <soapenv:Body>\n  " \
                                                                     "    <ns:executeSQLQuery sequence=\"\">\n        " \
                                                                     " <sql>\n         SELECT eu.userid AS id, " \
                                                                     "eu.firstname AS first, eu.lastname AS last, " \
                                                                     "eu.islocaluser AS homecluster, ucp.name AS " \
                                                                     "serviceprofile\n         FROM enduser AS eu\n   " \
                                                                     "      INNER JOIN ucserviceprofile AS ucp ON " \
                                                                     "ucp.pkid=eu.fkucserviceprofile WHERE " \
                                                                     "eu.islocaluser='t'\n         </sql>\n      " \
                                                                     "</ns:executeSQLQuery>\n   " \
                                                                     "</soapenv:Body>\n</soapenv:Envelope> "
    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print()
    print('Collecting Data...')
    print()
    # Here's where we send a POST message out to CUCM, we don't verify certificates.
    response = requests.request("POST", url, headers=headers, data=payload, auth=(cucmusername, cucmpassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    print('Data Collected. Please see file HomeClusterReport' + timestr + cucmipaddr + '.xml.')
    with open(os.path.join(completepath, 'HomeClusterReport_' + timestr + '_' + cucmipaddr + '.xml'), 'w+') as file:
        file.write(xml_pretty_str)


# Option 1 > 4
# Function that constructs csv string to check against ucm from file input.
def inputfetch():
    inputfile = input('What is the name of the input text file?: ')
    with open(inputfile) as txtfile:
        lines = [line.rstrip() for line in txtfile]
        for line in txtfile:
            lines.append(line)
        x = ",".join(lines)
    return x


# Options 1 > 3, 5
# Chunker function that breaks up list 'text' into chunks of 200
def chunker(text, chunk_size):
    iterlist = iter(text)
    while True:
        chunk = []
        try:
            for i in range(chunk_size):
                chunk.append(next(iterlist))
            yield chunk
        except StopIteration:
            if chunk:
                yield chunk
            return


# Options 1 > 3, 5
# Function that parses xml file and strips xml specific data and joins each device name in in the xml doc.
def get_devicenames(chunk_size=200):
    tree = ET.parse('regcheckdevicelist.xml')
    for text in chunker(
            (child.text for child in tree.iter() if not child.text.strip() == ''), chunk_size):
        yield ",".join(text)


# Option 1 > 3
# Function to query UCM for device pool list and present to the user, in case they don't know. Returns selected DP.
def collectdevicepool(cucmipaddr, cucmusername, cucmpassword, cucmversion):
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/" + version + "\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      " \
              "<ns:executeSQLQuery sequence=\"\">\n         <sql>\n            SELECT name\n            FROM " \
              "devicepool\n         </sql>\n      </ns:executeSQLQuery>\n   </soapenv:Body>\n</soapenv:Envelope> "
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    response = requests.request("POST", axlurl + cucmipaddr + '/axl/', headers=headers, data=payload,
                                auth=(cucmusername, cucmpassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    with open('devicepoollist.xml', 'w+') as file:
        file.write(xml_pretty_str)
    parse = ET.parse('devicepoollist.xml')
    entry = [child.text for child in parse.iter() if not child.text.strip() == '']
    dplist = "\n".join(entry)
    print()
    print('Device Pools Available:')
    print()
    print(dplist)
    print()
    devicepool = str(input('What is the Device Pool name?: '))
    return devicepool


# Option 1 > 3
# Function that dips into ccm db and executes SQL Query via SOAP. Returns devices in specified device pool.
def ucmdbdip_dp(cucmipaddr, cucmversion, cucmpassword, cucmusername, cucmdevicepool):
    # Define payload specific to ucmdbdip for specified device pool.
    payload = '<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" ' \
              'xmlns:ns=\"http://www.cisco.com/AXL/API/10.5\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      ' \
              '<ns:executeSQLQuery sequence=\"\">\n         <sql>\n            SELECT d.name \n            FROM ' \
              'device as d \n            INNER JOIN devicepool as dp ON dp.pkid=d.fkdevicepool \n            WHERE ' \
              'dp.name ' \
              'like \"' + cucmdevicepool + '\"\n         </sql>\n      </ns:executeSQLQuery>\n   ' \
                                           '</soapenv:Body>\n</soapenv:Envelope> '
    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print()
    print('Collecting Data...')
    print()
    response = requests.request("POST", axlurl + cucmipaddr + '/axl/', headers=headers, data=payload,
                                auth=(cucmusername, cucmpassword), verify=False)
    # We encode the text response from POST request as utf8 and pretty print it to a file
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    with open('regcheckdevicelist.xml', 'w+') as file:
        file.write(xml_pretty_str)


# Option 1 > 5
# Function that dips into ccm db and executes SQL Query via SOAP. Returns devices in specified device pool.
def ucmdbdip_all(cucmipaddr, cucmversion, cucmpassword, cucmusername):
    # Define payload specific to ucmdbdip for all devices.
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/10.5\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      " \
              "<ns:executeSQLQuery sequence=\"\">\n         <sql>\n            SELECT d.name\n            FROM " \
              "device\n            AS d order by d.name\n         </sql>\n      </ns:executeSQLQuery>\n   " \
              "</soapenv:Body>\n</soapenv:Envelope> "
    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print()
    print('Collecting Data...')
    print()
    response = requests.request("POST", axlurl + cucmipaddr + '/axl/', headers=headers, data=payload,
                                auth=(cucmusername, cucmpassword), verify=False)
    # We encode the text response from POST request as utf8 and pretty print it to a file
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    with open('regcheckdevicelist.xml', 'w+') as file:
        file.write(xml_pretty_str)


# Options 1 > 3, 4, 5
# Function to hit AST interface using device name list generated by createdevstring function.
def checkregstate(cucmipaddr, cucmpassword, cucmusername, devname):
    try:
        response = requests.get(axlurl + cucmipaddr + '/ast/ASTIsapi.dll?OpenDeviceSearch?Type=&NodeName'
                                                       '=&SubSystemType=&Status=1&DownloadStatus=&MaxDevices=200'
                                                       '&Model=&SearchType=Name&Protocol=Any&SearchPattern=' + devname,
                                verify=False,
                                auth=(cucmusername, cucmpassword))
        devicelist = devname.split(",")
        xmlresponse = ET.fromstring(response.content)
        for item in xmlresponse.iter('DeviceReply'):
            # If the amount of devices found is not zero, proceed to look for the device name. If it's not found,
            # say so
            if item.attrib['TotalDevices'] == '0':
                print('No queried devices were registered per UCM AST API.')
                exit()
            else:
                continue
        xmltag = xmlresponse.findall('.//ReplyNode/Device')
        for response in xmltag:
            if response.attrib['Name'] in devicelist:
                ipaddr = response.attrib['IpAddress']
                device = response.attrib['Name']
                if response.attrib.get('Description') is not None:
                    descr = response.attrib['Description']
                else:
                    descr = "No Description"
                status = "Registered"
                with open(os.path.join(completepath, 'RegisteredDevicesReport' + timestr + '.txt'), 'a+') as rdr:
                    rdr.write(ipaddr + ' ' + device + ' ' + descr + ' ' + status + '\n')
                devicelist.remove(response.attrib['Name'])
                continue
        for devicename in devicelist:
            if response.attrib['Name'] != devicename:
                with open(os.path.join(completepath, 'UnregisteredDevicesReport' + timestr + '.txt'), 'a+') as udr:
                    udr.write('Device ' + devicename + ' is not registered.' + '\n')
                devicelist.remove(devicename)
    except requests.exceptions.ConnectionError:
        print('Connection error occurred. Unable to get HTTP Response from CUCM AST Interface. Check connectivity.')
    except requests.exceptions.Timeout:
        print('Connection timed out to UCM AST Interface.')


# Check if tmp directory exists.
if os.path.exists(dirname) is False:
    os.mkdir(dirname)
    print('####################################################################################################')
    print('Folder ' + dirname + ' has been created in current directory. Generated reports will be found there.')
    print('####################################################################################################')

# Call Menu
menu()
