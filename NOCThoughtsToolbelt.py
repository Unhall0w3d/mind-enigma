#!/usr/var/python
# -*- code:UTF-8 -*-

#####################################
# Script created by Ken Perry, 2020 #
#       NOC THOUGHTS BLOG           #
# https://nocthoughts.wordpress.com #
#####################################

# Modules Imported for Script Functionality
import subprocess
import time
import xml.etree.ElementTree as ET
from io import BytesIO
import os

import pycurl
import requests
import urllib3
import xml.dom.minidom
from getpass import getpass

# Define Variables
timestr = time.strftime("%Y%m%d-%H%M%S")

# Define disablement of HTTPS Insecure Request error message.
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Define Base URL
baseurl = 'https://'


# Define Main Menu
def menu():
    print()
    choice = input("""
                      1: Cisco Phone Requests
                      2: Cisco UCM Requests
                      3: Unimplemented
                      Q: Quit

                      Selection: """)

    if choice == "1":
        phonemenuchoice = input("""
                                1: Pull Cisco Phone Info
                                2: Pull Cisco Phone Logs
                                3: Pull Cisco Phone Registration
                                Q: Quit

                                Selection: """)
        if phonemenuchoice == "1":
            serialnumpull()
            menu()
        elif phonemenuchoice == "2":
            ips = phonecollection()
            [logcollect(ip_addr) for ip_addr in ips]
            print('############# Files have been stored in ~/ in an IP specific folder #############')
            menu()
        elif phonemenuchoice == "3":
            # User input collection provided by infocollect function
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            # Collect device pool
            cucmdevicepool = collectdevicepool(cucmipaddr, cucmusername, cucmpassword, cucmversion)
            # Call DB Dip Function to execute sql query and prettyprint xml response to file
            ucmdbdip(cucmipaddr, cucmversion, cucmpassword, cucmusername, cucmdevicepool)
            # Hit AST interface to check reg status using csv string generated by createdevstring function
            checkregstate(cucmipaddr, cucmpassword, cucmusername, cucmdevicepool)
            menu()
    elif choice == "2":
        ucmmenuchoice = input("""
                                  1: Pull UCM Device Defaults
                                  2: Pull UCM Phones Configured
                                  3: Pull Jabber Last Login Time
                                  4: Pull Devices w/ Static Firmware Assignment
                                  Q: Quit

                                  Selection: """)
        if ucmmenuchoice == "1":
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            devicedefaultsfetch(cucmipaddr, cucmversion, cucmpassword, cucmusername)
            menu()
        elif ucmmenuchoice == "2":
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            ccmphonereport(cucmipaddr, cucmversion, cucmpassword, cucmusername)
            menu()
        elif ucmmenuchoice == "3":
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            jabberlastloginreport(cucmipaddr, cucmversion, cucmpassword, cucmusername)
            menu()
        elif ucmmenuchoice == "4":
            cucmipaddr, cucmversion, cucmpassword, cucmusername = infocollect()
            devicestaticfirmwareassignment(cucmipaddr, cucmversion, cucmpassword, cucmusername)
            menu()
        elif ucmmenuchoice == "q" or "Q":
            exit()
    elif choice == "3":
        print("Not Implemented")
        exit()
    elif choice == "q" or choice == "Q":
        exit()
    else:
        print("You must select an option on the menu.")
        print("Please try again.")
        menu()


# Log collection function that runs wget against consolelog url to pull recursively.
def logcollect(ip_addr):
    destfolder = str('~/')
    uris = list({
        '/CGI/Java/Serviceability?adapter=device.statistics.consolelog',
        '/localmenus.cgi?func=603',
        '/ConsoleLogs',
        '/Console_Logs.htm',
        '/Console_Logs.html',
        '/?adapter=device.statistics.consolelog',
    })
    for uri in uris:
        try:
            response = requests.get(f'http://{ip_addr}{uri}', timeout=6)
            if response.status_code == 200:
                subprocess.call(
                    'wget -T 5 --tries=2 -r --accept "*.log, messages*, *.tar.gz" http://' + ip_addr + uri + ' -P '
                    + destfolder,
                    shell=True)
        except requests.exceptions.ConnectionError:
            print('Far end ' + ip_addr + 'has closed the connection.')
        except requests.exceptions.Timeout:
            print('Connection to ' + ip_addr + ' timed out. Trying next.')
        except Exception as e:
            print('The script failed. Contact script dev with details from your attempt and failure.')
            print(e)


def phonecollection():
    num_phones = int(input('How many phones?: '))
    if type(num_phones) != int:
        print('Error: Expected Integer.')
        exit(1)
    ips = []
    for phonecount in range(num_phones):
        ips.append(input('What is the phone IP address?: '))
    return ips


def getxmldata(ip_addr, uri):
    buffer = BytesIO()
    curl = pycurl.Curl()
    _url = f'http://{ip_addr}{uri}'
    curl.setopt(pycurl.CONNECTTIMEOUT, 5)
    curl.setopt(curl.URL, _url)
    curl.setopt(curl.WRITEDATA, buffer)
    try:
        curl.perform()
        curl.close()
        return ET.fromstring((buffer.getvalue()))
    except pycurl.error:
        print()
        print('Connection Timed Out. No response after 5 seconds for ' + ip_addr + '.')


def serialnumpull():
    xmluris = ['/NetworkConfigurationX', '/DeviceInformationX']
    inputfile = input('What is the name of the input text file? (e.g. iplist.txt): ')
    with open(inputfile) as txtfile:
        lines = [line.rstrip() for line in txtfile]
        for line in txtfile:
            lines.append(line)
    for ipaddy in lines:
        try:
            for uri in xmluris:
                root = getxmldata(ipaddy, uri)
                if root == -1:
                    break
                if root is None:
                    continue
                _root = uri.strip('/X')
                for xmltag in root.iter(_root):
                    if xmltag.find('HostName') is not None:
                        macaddr = xmltag.find('HostName').text
                    if xmltag.find('modelNumber') is not None:
                        modelnum = xmltag.find('modelNumber').text
                    if xmltag.find('serialNumber') is not None:
                        serialnum = xmltag.find('serialNumber').text
                    else:
                        serialnum = "n/a"
                    for i in range(2):
                        if xmltag.find('CallManager%s' % (i + 1)) is not None:
                            if xmltag.find('CallManager%s' % (i + 1)).text.find('Active') != -1:
                                cucmreg = xmltag.find('CallManager%s' % (i + 1)).text
            if root == -1:
                continue
            print()
            print("IP:", ipaddy, "DeviceName:", macaddr, "Model:",
                  modelnum, "Serial Number:", serialnum, "Reg State:", cucmreg)
        except Exception as m:
            print(m)
            exit(2)
    return


def devicedefaultsfetch(ccmip, version, mypassword, myusername):
    # URL to hit for request against axl
    url = (baseurl + ccmip + '/axl/')

    # Payload to send; soap envelope
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/" + version + "\">\n<!--Like https://[CCM-IP-ADDRESS]/ccmadmin > Device > " \
              "Device Settings > Device Defaults -->\n   <soapenv:Header/>\n   <soapenv:Body>\n      <ns:executeSQLQuery " \
              "sequence=\"\">\n         <sql>\n        SELECT count(dev.tkmodel), tp.name, defaults.tkdeviceprotocol, " \
              "defaults.loadinformation, dev.tkmodel AS tkmodel \n        FROM device AS dev \n        INNER JOIN " \
              "TypeProduct AS tp ON dev.tkmodel=tp.tkmodel \n        INNER JOIN defaults as defaults ON " \
              "tp.tkmodel=defaults.tkmodel \n        WHERE (dev.name like 'SEP%' or dev.name like 'ATA%') \n        GROUP " \
              "BY dev.tkmodel, tp.name, defaults.loadinformation, defaults.tkdeviceprotocol\n         </sql>\n      " \
              "</ns:executeSQLQuery>\n   </soapenv:Body>\n</soapenv:Envelope> "

    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + version + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print('Collecting Data...')
    # Here's where we send a POST message out to CUCM, we don't verify certificates.
    response = requests.request("POST", url, headers=headers, data=payload, auth=(myusername, mypassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    print('Data Collected. Please see file DeviceDefaults' + timestr + ccmip + '.xml.')
    with open('DeviceDefaults_' + timestr + '_' + ccmip + '.xml', 'w+') as file:
        file.write(xml_pretty_str)


def ccmphonereport(ccmip, version, mypassword, myusername):
    # URL to hit for request against axl
    url = (baseurl + ccmip + '/axl/')

    # Payload to send; soap envelope
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/10.5\">\n<!-- SQL Data Pull for Device Name, Description, " \
              "DN and Partition the DN Sits in for Basic Reporting -->\n   <soapenv:Header/>\n   <soapenv:Body>\n     " \
              " <ns:executeSQLQuery sequence=\"\">\n         <sql>\n\t\t\tSELECT d.name,d.description,n.dnorpattern " \
              "as DN,rp.name as partition\n\t\t\tFROM device as d\n\t\t\tINNER join devicenumplanmap as dmap on " \
              "dmap.fkdevice=d.pkid\n\t\t\tINNER join numplan as n on dmap.fknumplan=n.pkid\n\t\t\tINNER join " \
              "routepartition as rp on n.fkroutepartition=rp.pkid\n\t\t\tWHERE d.tkclass=1\n\t\t\tORDER by d.name\n   " \
              "      </sql>\n      </ns:executeSQLQuery>\n   </soapenv:Body>\n</soapenv:Envelope> "

    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + version + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print('Collecting Data...')
    # Here's where we send a POST message out to CUCM, we don't verify certificates.
    response = requests.request("POST", url, headers=headers, data=payload, auth=(myusername, mypassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    print('Data Collected. Please see file PhoneReport' + timestr + ccmip + '.xml.')
    with open('PhoneReport_' + timestr + '_' + ccmip + '.xml', 'w+') as file:
        file.write(xml_pretty_str)


def jabberlastloginreport(ccmip, version, mypassword, myusername):
    # URL to hit for request against axl
    url = (baseurl + ccmip + '/axl/')
    # Payload to send; soap envelope
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/10.5\">\n<!--Verifies the last time a Jabber user logged in, " \
              "or the last time their profile was accessed-->\n   <soapenv:Header/>\n   <soapenv:Body>\n      " \
              "<ns:executeSQLQuery sequence=\"\">\n         <sql>\n            SELECT e.userid, cd.timelastaccessed\n " \
              "           FROM enduser as e, credentialdynamic as cd, credential as cr\n            WHERE " \
              "e.pkid=cr.fkenduser and e.tkuserprofile=1 and e.primarynodeid is not null and cr.tkcredential=3 and " \
              "cr.pkid=cd.fkcredential\n            ORDER by cd.timelastaccessed\n         </sql>\n      " \
              "</ns:executeSQLQuery>\n   </soapenv:Body>\n</soapenv:Envelope> "
    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + version + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print('Collecting Data...')
    # Here's where we send a POST message out to CUCM, we don't verify certificates.
    response = requests.request("POST", url, headers=headers, data=payload, auth=(myusername, mypassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    print('Data Collected. Please see file JabberLastLogin' + timestr + ccmip + '.xml.')
    with open('JabberLastLogin_' + timestr + '_' + ccmip + '.xml', 'w+') as file:
        file.write(xml_pretty_str)


def devicestaticfirmwareassignment(ccmip, version, mypassword, myusername):
    # URL to hit for request against axl
    url = (baseurl + ccmip + '/axl/')
    # Payload to send; soap envelope
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/10.5\">\n<!-- Like https://[CCM-IP-ADDRESS]/ccmadmin > Device " \
              "> Device Settings > Device Firmware Load Information -->\n   <soapenv:Header/>\n   <soapenv:Body>\n    " \
              "  <ns:executeSQLQuery sequence=\"\">\n         <sql>\n            SELECT d.name, " \
              "d.specialloadinformation, d.description, tp.name AS model\n            FROM device AS d\n            " \
              "INNER JOIN TypeProduct AS tp ON d.tkmodel=tp.tkmodel\n            WHERE d.name like 'SEP%' AND " \
              "d.specialloadinformation != ''\n         </sql>\n      </ns:executeSQLQuery>\n   " \
              "</soapenv:Body>\n</soapenv:Envelope>\n "

    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + version + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    print('Collecting Data...')
    # Here's where we send a POST message out to CUCM, we don't verify certificates.
    response = requests.request("POST", url, headers=headers, data=payload, auth=(myusername, mypassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    print('Data Collected. Please see file DevicesStaticFirmwareAssignment' + timestr + ccmip + '.xml.')
    with open('DevicesStaticFirmwareAssignment_' + timestr + '_' + ccmip + '.xml', 'w+') as file:
        file.write(xml_pretty_str)


# Chunker function that breaks up list 'text' into chunks of 200
def chunker(text, chunk_size):
    iterlist = iter(text)
    while True:
        chunk = []
        try:
            for i in range(chunk_size):
                chunk.append(next(iterlist))
            yield chunk
        except StopIteration:
            if chunk:
                yield chunk
            return


# Function that parses xml file and strips xml specific data and joins each device name in in the xml doc.
def get_devicenames(chunk_size=200):
    tree = ET.parse('regcheckdevicelist.xml')
    for text in chunker(
            (child.text for child in tree.iter() if not child.text.strip() == ''), chunk_size):
        yield ",".join(text)


# Function that gathers input from user for required parameters.
def infocollect():
    # Define user input required for script; pub ip, username, pw
    ccmip = str(input('What is the CUCM Pub IP?: '))
    print('Supported UCM SQL DB Versions: 12.5 | 12.0 | 11.5 | 11.0 | 10.5 | 10.0 | 9.1 | 9.0')
    version = str(input('What version is UCM?: '))
    myusername = str(input('What is the GUI Username?: '))
    mypassword = getpass('What is the GUI Password?: ')
    return ccmip, version, mypassword, myusername


# Function to query UCM for device pool list and present to the user, in case they don't know. Returns selected DP.
def collectdevicepool(cucmipaddr, cucmusername, cucmpassword, cucmversion):
    payload = "<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" " \
              "xmlns:ns=\"http://www.cisco.com/AXL/API/10.5\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      " \
              "<ns:executeSQLQuery sequence=\"\">\n         <sql>\n            SELECT name\n            FROM " \
              "devicepool\n         </sql>\n      </ns:executeSQLQuery>\n   </soapenv:Body>\n</soapenv:Envelope> "
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    response = requests.request("POST", baseurl + cucmipaddr + '/axl/', headers=headers, data=payload,
                                auth=(cucmusername, cucmpassword), verify=False)
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    with open('devicepoollist.xml', 'w+') as file:
        file.write(xml_pretty_str)
    parse = ET.parse('devicepoollist.xml')
    entry = [child.text for child in parse.iter() if not child.text.strip() == '']
    dplist = "\n".join(entry)
    print()
    print('Device Pools Available:')
    print()
    print(dplist)
    print()
    devicepool = str(input('What is the Device Pool name?: '))
    return devicepool


# Function that dips into ccm db and executes SQL Query via SOAP. Returns devices in specified device pool.
def ucmdbdip(cucmipaddr, cucmversion, cucmpassword, cucmusername, cucmdevicepool):
    # Payload to send; soap envelope
    payload = '<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" ' \
              'xmlns:ns=\"http://www.cisco.com/AXL/API/10.5\">\n   <soapenv:Header/>\n   <soapenv:Body>\n      ' \
              '<ns:executeSQLQuery sequence=\"\">\n         <sql>\n            SELECT d.name \n            FROM ' \
              'device as d \n            INNER JOIN devicepool as dp ON dp.pkid=d.fkdevicepool \n            WHERE ' \
              'dp.name ' \
              'like \"' + cucmdevicepool + '\"\n         </sql>\n      </ns:executeSQLQuery>\n   ' \
                                           '</soapenv:Body>\n</soapenv:Envelope> '

    # Header content, define db version and execute an SQL Query
    headers = {
        'SOAPAction': 'CUCM:DB ver=' + cucmversion + ' executeSQLQuery',
        'Content-Type': 'text/plain'
    }
    # Here's where we verify reachability of the AXL interface for DB dip.
    try:
        reachabilitycheck = requests.get(baseurl + cucmipaddr + '/axl', auth=(cucmusername, cucmpassword), verify=False)
        if reachabilitycheck.status_code != 200:
            print('AXL Interface at ' + baseurl + cucmipaddr + '/axl/ is not available, or some other error. '
                                                               'Please verify CCM AXL Service Status.')
            print(reachabilitycheck.status_code)
            print('Contact script dev to create exception or handle response code.')
            exit()
        elif reachabilitycheck.status_code == 200:
            print()
            print('AXL Interface is working and accepting requests.')
    except requests.exceptions.ConnectionError:
        print('Connection error occurred. Unable to get HTTP Response from CUCM AXL Interface. Check connectivity.')
    except requests.exceptions.Timeout:
        print('Connection timed out to UCM AXL Interface.')
    except Exception as m:
        print(m)
    print()
    print('Collecting Data...')
    response = requests.request("POST", baseurl + cucmipaddr + '/axl/', headers=headers, data=payload,
                                auth=(cucmusername, cucmpassword), verify=False)
    # We encode the text response from POST request as utf8 and pretty print it to a file
    uglyxml = response.text.encode('utf8')
    xmldata = xml.dom.minidom.parseString(uglyxml)
    xml_pretty_str = xmldata.toprettyxml()
    with open('regcheckdevicelist.xml', 'w+') as file:
        file.write(xml_pretty_str)


# Function to hit AST interface using device name list generated by createdevstring function.
def checkregstate(cucmipaddr, cucmpassword, cucmusername, cucmdevicepool):
    # Inform the user what device pool this report is for.
    print()
    print('Registration Report Below For Device Pool: ' + cucmdevicepool + '.')
    print()
    # Pull in device names to check for AST
    for devname in get_devicenames():
        try:
            response = requests.get(baseurl + cucmipaddr + '/ast/ASTIsapi.dll?OpenDeviceSearch?Type=&NodeName'
                                                           '=&SubSystemType=&Status=1&DownloadStatus=&MaxDevices=200'
                                                           '&Model=&SearchType=Name&Protocol=Any&SearchPattern=' + devname,
                                    verify=False,
                                    auth=(cucmusername, cucmpassword))
            devicelist = devname.split(",")
            xmlresponse = ET.fromstring(response.content)
            for item in xmlresponse.iter('DeviceReply'):
                # If the amount of devices found is not zero, proceed to look for the device name. If it's not found,
                # say so
                if item.attrib['TotalDevices'] == '0':
                    print('No queried devices were registered per UCM AST API.')
                    exit()
                else:
                    continue
            xmltag = xmlresponse.findall('.//ReplyNode/Device')
            for response in xmltag:
                if response.attrib['Name'] in devicelist:
                    ipaddr = response.attrib['IpAddress']
                    device = response.attrib['Name']
                    descr = response.attrib['Description']
                    status = response.attrib['Status']
                    print('Report for Registered Devices can be found in RegisteredDevicesReport' + timestr + '.txt')
                    with open('RegisteredDevicesReport' + timestr + '.txt', 'a+') as rdr:
                        rdr.write(ipaddr + ' ' + device + ' ' + descr + ' ' + status + '\n')
                    continue
            for devicename in devicelist:
                if response.attrib['Name'] != devicename:
                    print('Report for Unregistered Devices can be found in UnregisteredDevicesReport' + timestr + '.txt')
                    with open('UnregisteredDevicesReport' + timestr + '.txt', 'a+') as udr:
                        udr.write('Device ' + devicename + ' is not registered.' + '\n')
        except requests.exceptions.ConnectionError:
            print('Connection error occurred. Unable to get HTTP Response from CUCM AST Interface. Check connectivity.')
        except requests.exceptions.Timeout:
            print('Connection timed out to UCM AST Interface.')
        except Exception as p:
            print(p)
    os.remove("regcheckdevicelist.xml")
    os.remove("devicepoollist.xml")


# Call Menu
menu()
